---
title: 反柯里化
tags:
  - 反柯里化
  - 柯里化
url: 2150.html
id: 2150
comments: false
categories:
  - 编程随想
date: 2017-08-02 19:01:35
---

多年前看腾讯前端的一篇技术文章讲反柯里化的，原来只是觉得很神奇，完全看不懂。今天尝试着自己去实现一下uncurry这个函数，反而一下就想明白了。 所谓反柯里化对应于柯里化的概念，就是说，把原来已经固定的参数或者this上下文等当作参数延迟到未来传递。比如我们经常有这样的需求（把ArrayLike转为Array）:

    var arr = Array.prototype.slice.call(document.querySelectorAll('script'))
    

如果需要每次都写这么一长串`Array.prototype.slice.call`必然不是做技术的该有的态度。 我们可能期望的是有slice这么个函数，然后直接这样使用：

    var slice = Array.prototype.slice.uncurry();
    var arr = slice(document.querySelectorAll('script'))
    

uncurry实现如下：

    Function.prototype.uncrrying = function(){
        let self = this;
        return function(...arg){
            return Function.prototype.call.apply(self,arg)  
            //return self.apply(arg.splice(0,1)[0],arg)   //这样亦可
        }
    }
    

其实如果在支持`Function.prototype.bind`的环境还有更快得到slice的方式：

    var slice = Function.prototype.call.bind(Array.prototype.slice);