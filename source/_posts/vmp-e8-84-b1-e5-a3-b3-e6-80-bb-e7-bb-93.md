---
title: VMP脱壳总结
tags:
  - VMP
  - 破解
  - 脱壳
url: 278.html
id: 278
categories:
  - 脱壳破解
date: 2011-05-10 12:38:35
---

个人在学习脱**VMP**加壳的过程中总结的一个步骤。按照这个步骤，包括**VMP**1.6—2.0在内应该有70%-80%能脱壳。脱不了的也别问我，我也刚开始学习。我还想找人问呢。 想要脱**VMP**的壳，首要工作当然是要找一个强OD啦！至于是什么版本的OD自己多试验几个，网上大把大把的，一般来说只要加载了你想脱的**VMP**加壳程序不关闭都可以。 其次就是StrongOD.dll这个插件了，现在用的比较多的就是海风月影，同样网上也是大把大把的。下载回来后复制到你的OD程序所在的文件夹里面的plugin里。StrongOD的设置选项搞不懂就全部打钩。 接下来要做的工作就是搞清楚我们要脱壳的程序编程的语言了，可以用PEID或者fastscanner查看,如果在这里看不到也可以在OD载入以后通过里面的字符串判断了。例如VB的程序会出现MSVB----/VC的会出现MSVC---等等。这些都是程序运行所需要的windows链接文件。 做完这些预备工作接下来当然是用OD载入文件啦。文件载入后在反汇编窗口CTRL+G搜索VirtualProtect(注意V跟P要大写，至于为什么要搜索这个别问我)。一般来说搜索的结果会出现以下的类似： 7C801AE3    E8 75FFFFFF     call kernel32.VirtualProtectEx 我们在这里下F2断点。然后F9运行到我们下的这个断点。接下来我们就要注意观察堆栈窗口了。一般来说当我们F9运行到我们上面下的断点的时候在堆栈窗口会出现以下类似： 0012F66C   00401000  |Address = TradeCen.00401000 0012F670   000280D1  |Size = 280D1 (164049.) 0012F674   00000004  |NewProtect = PAGE\_READWRITE 0012F678   0012FF98  \\pOldProtect = 0012FF98 我们要注意观察的就是在接下来我们F9运行的时候，ADDRESS和NEWPROTECT这两行的变化。按F9-速度别太快，直到NewProtect项变为PAGE\_READONLY，这时候程序就释放完毕了。 0012F66C   0042A000  |Address = TradeCen.0042A000 0012F670   000069DE  |Size = 69DE (27102.) 0012F674   00000002  |NewProtect = PAGE\_READONLY 0012F678   0012FF98  \\pOldProtect = 0012FF98 现在可以取消刚才我们下的断点了。接下来就是找OEP了。找OEP的时候我个人的一个经验就是OEP一般就在接近上面的ADDRESS地址的附近。例如上面的地址是0042A000，我一般就在这个基础上减到420000搜索程序的特征段，当然我们也可以直接跳到401000开始搜索。虽然我们搜索的范围比较大，但是因为我们搜索的是命令序列，所以工作量还不是很大。 废话不多说，CTRL+G--上面的地址，然后CTRL+S 查找命令序列。命令序列的内容就是我们用查到的编程语言的特征段。我们可以在特征段里面选择两三句固定不变的命令查找。例如VC++6.0的特征段是 0046C07B U>  55                push ebp 0046C07C     8BEC              mov ebp,esp 0046C07E     6A FF             push -1 0046C080     68 18064C00       push UltraSna.004C0618 0046C085     68 F8364700       push UltraSna.004736F8 0046C08A     64:A1 00000000    mov eax,dword ptr fs:\[0\] 0046C090     50                push eax 0046C091     64:8925 00000000  mov dword ptr fs:\[0\],esp 0046C098     83EC 58           sub esp,58 0046C09B     53                push ebx 0046C09C     56                push esi 0046C09D     57                push edi 我们可以只搜索前三条命令。找到符合前三条命令的，我们在对照接下来的命令。只要命令相符那这个地址八九不离十就是OEP了。如果在ADDRESS地址附近找不到OEP，那就只好用笨办法，从401000开始找吧。 找到OEP地址后，我们在OEP处点鼠标右键《此处为新EIP》。接下来就可以dump啦。通常选择OD的dump插件脱壳要好点，用loadpe脱壳后要么程序不运行要么干脆没脱。用OD的dump插件脱壳的时候，脱壳窗口下面的（重建输入表）项前面的勾一定要去掉，这个也是前辈总结的经验。 到此脱壳就结束了。可以试验一下脱壳后的程序了。能运行说明它在70-80%的范围，不能运行的话那也是我还在学习的内容，大家共同探讨！ 以下是主要几种编程语言的OEP特征段： Borland C++ 0040163C B> /EB 10             jmp short Borland\_.0040164E 0040163E    |66:623A           bound di,dword ptr ds:\[edx\] 00401641    |43                inc ebx 00401642    |2B2B              sub ebp,dword ptr ds:\[ebx\] 00401644    |48                dec eax 00401645    |4F                dec edi 00401646    |4F                dec edi 00401647    |4B                dec ebx 00401648    |90                nop 00401649   -|E9 98E04E00       jmp SHELL32.008EF6E6 0040164E    \\A1 8BE04E00       mov eax,dword ptr ds:\[4EE08B\] 00401653     C1E0 02           shl eax,2 00401656     A3 8FE04E00       mov dword ptr ds:\[4EE08F\],eax 0040165B     52                push edx 0040165C     6A 00             push 0 0040165E     E8 DFBC0E00       call <jmp.&KERNEL32.GetModuleHandleA> ********************************************************************************** Delphi 00458650 D>  55                push ebp 00458651     8BEC              mov ebp,esp 00458653     83C4 F0           add esp,-10 00458656     B8 70844500       mov eax,Delphi.00458470 0045865B     E8 00D6FAFF       call Delphi.00405C60 00458660     A1 58A14500       mov eax,dword ptr ds:\[45A158\] 00458665     8B00              mov eax,dword ptr ds:\[eax\] 00458667     E8 E0E1FFFF       call Delphi.0045684C 0045866C     A1 58A14500       mov eax,dword ptr ds:\[45A158\] 00458671     8B00              mov eax,dword ptr ds:\[eax\] 00458673     BA B0864500       mov edx,Delphi.004586B0 00458678     E8 DFDDFFFF       call Delphi.0045645C 0045867D     8B0D 48A24500     mov ecx,dword ptr ds:\[45A248\]            ; Delphi.0045BC00 00458683     A1 58A14500       mov eax,dword ptr ds:\[45A158\] 00458688     8B00              mov eax,dword ptr ds:\[eax\] 0045868A     8B15 EC7D4500     mov edx,dword ptr ds:\[457DEC\]            ; Delphi.00457E38 00458690     E8 CFE1FFFF       call Delphi.00456864 00458695     A1 58A14500       mov eax,dword ptr ds:\[45A158\] 0045869A     8B00              mov eax,dword ptr ds:\[eax\] 0045869C     E8 43E2FFFF       call Delphi.004568E4 ********************************************************************************** Visual C++ 6.0 0046C07B U>  55                push ebp 0046C07C     8BEC              mov ebp,esp 0046C07E     6A FF             push -1 0046C080     68 18064C00       push UltraSna.004C0618 0046C085     68 F8364700       push UltraSna.004736F8 0046C08A     64:A1 00000000    mov eax,dword ptr fs:\[0\] 0046C090     50                push eax 0046C091     64:8925 00000000  mov dword ptr fs:\[0\],esp 0046C098     83EC 58           sub esp,58 0046C09B     53                push ebx 0046C09C     56                push esi 0046C09D     57                push edi 0046C09E     8965 E8           mov dword ptr ss:\[ebp-18\],esp 0046C0A1     FF15 74824A00     call dword ptr ds:\[<&KERNEL32.GetVersion>\]  ; kernel32.GetVersion 0046C0A7     33D2              xor edx,edx 0046C0A9     8AD4              mov dl,ah 0046C0AB     8915 403F4F00     mov dword ptr ds:\[4F3F40\],edx 0046C0B1     8BC8              mov ecx,eax 0046C0B3     81E1 FF000000     and ecx,0FF 0046C0B9     890D 3C3F4F00     mov dword ptr ds:\[4F3F3C\],ecx ********************************************************************************** Visual C++ 7.0 0100739D > $  6A 70         push 0x70 0100739F   .  68 98180001   push NOTEPAD.01001898 010073A4   .  E8 BF010000   call NOTEPAD.01007568 010073A9   .  33DB          xor ebx,ebx ********************************************************************************** 汇编 00401000 汇>  6A 00            push 0 00401002     E8 C50A0000       call <jmp.&KERNEL32.GetModuleHandleA> 00401007     A3 0C354000       mov dword ptr ds:\[40350C\],eax 0040100C     E8 B50A0000       call <jmp.&KERNEL32.GetCommandLineA> 00401011     A3 10354000       mov dword ptr ds:\[403510\],eax 00401016     6A 0A             push 0A 00401018     FF35 10354000     push dword ptr ds:\[403510\] 0040101E     6A 00             push 0 00401020     FF35 0C354000     push dword ptr ds:\[40350C\] 00401026     E8 06000000       call 汇编.00401031 0040102B     50                push eax 0040102C     E8 8F0A0000       call <jmp.&KERNEL32.ExitProcess> 00401031     55                push ebp 00401032     8BEC              mov ebp,esp 00401034     83C4 B0           add esp,-50 00401037     C745 D0 30000000  mov dword ptr ss:\[ebp-30\],30 0040103E     C745 D4 0B000000  mov dword ptr ss:\[ebp-2C\],0B 00401045     C745 D8 37114000  mov dword ptr ss:\[ebp-28\],汇编.00401137 ********************************************************************************** VB 0040116C V>/$  68 147C4000     push VB.00407C14 00401171   |.  E8 F0FFFFFF     call <jmp.&MSVBVM60.#100> 00401176   |.  0000            add byte ptr ds:\[eax\],al 00401178   |.  0000            add byte ptr ds:\[eax\],al 0040117A   |.  0000            add byte ptr ds:\[eax\],al 0040117C   |.  3000            xor byte ptr ds:\[eax\],al