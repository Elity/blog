---
title: '各种保护壳易语言的SDK代码 '
tags:
  - SDK
  - 保护壳
  - 加壳
  - 易语言
url: 1276.html
id: 1276
categories:
  - 编程随想
  - 脱壳破解
date: 2012-03-08 15:24:51
---

**ZProtect**

//Code_Confusion 是代码乱序加密标记，允许您选择一部分被乱序的代码  
置入代码 ({ 235, 8, 83, 84, 95, 83, 84, 65, 82, 84 }) ' Code_Confusion标记开始  
置入代码 ({ 235, 8, 83, 84, 95, 83, 84, 69, 78, 68 }) ' Code_Confusion标记结尾  
//Code_Elimination 是代码清除标记，允许您选择一部分代码在运行后从内存中删除；使用此标记的目的是为了防止破解者从内存中转储出完整的程序代码。  
置入代码 ({ 235, 8, 79, 67, 95, 83, 84, 65, 82, 84 }) ' Code_Elimination标记开始  
置入代码 ({ 235, 8, 79, 67, 95, 79, 67, 69, 78, 68 }) ' Code_Elimination标记结尾  
//Decode_onExec 是动态解码标记，允许您选择一部分只在执行时才解密的代码段；这部分代码仅在需要执行时才解码，执行前和执行后均处于加密状态  
置入代码 ({ 235, 8, 68, 89, 95, 83, 84, 65, 82, 84 }) // Decode_onExec标记开始  
置入代码 ({ 235, 8, 68, 89, 95, 68, 89, 69, 78, 68 }) // Decode_onExec标记结尾  
//Decode_onReg 是注册解码标记，允许您选择一部分使用有效密钥才解密的代码；如果注册密钥不正确，那么这部分代码将永远处于加密状态。通俗地讲，这部分代码仅在注册版中执行  
//源代码中可以使用任意数量的 Decode_onReg 标记，但是这些代码段在执行时会同时解密。注册解码标记主要用于激活未注册版中被限制的功能，使之注册成为完整版。  
置入代码 ({ 235, 8, 82, 68, 95, 83, 84, 65, 82, 84 }) // Decode_onReg标记开始  
置入代码 ({ 235, 8, 82, 68, 95, 82, 68, 69, 78, 68 }) // Decode_onReg标记结尾  
//Zprotect_VM 是虚拟机加密标记，允许您选择一部分代码放到虚拟机中运行；虚拟机的指令系统是完全不同于现有的 x86 指令，可以有效阻止代码还原及分析  
置入代码 ({ 235, 8, 86, 77, 95, 83, 84, 65, 82, 84 }) // Zprotect_VM标记开始  
置入代码 ({ 235, 8, 86, 77, 95, 86, 77, 69, 78, 68 }) // Zprotect_VM标记结尾  
-----------适用于ZProtect V1.4.9.0版本---------

**VMProtect.****易的****SDK**  
置入代码 ({ 235, 16, 86, 77, 80, 114, 111, 116, 101, 99, 116, 32, 98, 101, 103, 105, 110, 0 }) ' VMP保护开始标志  
'关键代码  
置入代码 ({ 235, 14, 86, 77, 80, 114, 111, 116, 101, 99, 116, 32, 101, 110, 100, 0 }) ' VMP保护结束标志

**Enigma****加密易语言的****SDK**  
置入代码 ({ 235, 10, 69, 67, 82, 79, 78, 69, 88, 69, 67, 66 })' 标记开始处  
'关键代码  
置入代码 ({ 235, 10, 69, 67, 82, 79, 78, 69, 88, 69, 67, 69 })' 标记结束处

**NoobyProtect****加密易语言的****SDK**  
置入代码 ({ 235, 6, 78, 80, 66, 69, 71, 78 })' 标记开始处  
'关键代码  
置入代码 ({ 235, 6, 78, 80, 69, 78, 68, 80 })' 标记结束处

**穿山甲调用功能型加密易语言****SDK****的****DEMO**  
置入代码 ({ 235, 3, 214, 215, 1 })' 标记开始处  
'关键代码  
置入代码 ({ 235, 3, 214, 215, 0 })' 标记结束处

**ASP****加密易语言****SDK**

置入代码 ({ 235, 4, 235, 5, 25, 1, 233, 37, 0 })' 标记开始处  
'关键代码  
置入代码 ({ 235, 4, 235, 5, 41, 1, 233, 133, 0, })' 标记结束处

**Shielden 2.0.1.0**   
置入代码 ({ 235, 7, 83, 69, 66, 69, 71, 78, 0 })  ' SE\_PROTECT\_START  
' 关键代码  
置入代码 ({ 235, 7, 83, 69, 69, 78, 68, 80, 0 })  ' SE\_PROTECT\_END

置入代码 ({ 235, 7, 83, 69, 66, 69, 71, 78, 77 })  ' SE\_PROTECT\_START_MUTATION  
关键代码  
置入代码 ({ 235, 7, 83, 69, 69, 78, 68, 80, 0 })  ' SE\_PROTECT\_END  
置入代码 ({ 235, 7, 83, 69, 66, 69, 71, 78, 85 })  ' SE\_PROTECT\_START_ULTRA  
关键代码  
置入代码 ({ 235, 7, 83, 69, 69, 78, 68, 80, 0 })  ' SE\_PROTECT\_END  
置入代码 ({ 235, 7, 83, 69, 66, 69, 71, 78, 86 })  '   
' 关键代码  
置入代码 ({ 235, 7, 83, 69, 69, 78, 68, 80, 0 })  ' SE\_PROTECT\_END

**易语言****SDK****转换方法****↓**  
随着E5.0静态编译对标准PE格式的支持，在E程序中引入加密壳SDK提升软件保护质量已经成为现实。  
加密壳SDK大体可划分为两类，一类是功能型SDK，一类是保护型SDK。  
一、功能性SDK。  
功能性SDK用来处理序列号验证、授权时间验证等功能性操作。这类SDK有直接应用的各种函数在壳里提供，如WL；也有需要引入外部DLL的，如穿山甲。  
对于无输出表的DLL，使用引入外部SDK，我们需要载入DLL，寻址SDK中的函数，通过E里边的调用子程序()命令可以很方便的对SDK函数完成传递参数获取返回值的操作，完事后把DLL一卸载就搞定了。  
对于有输出表的DLL，使用E的DLL命令进行调用就OK了。  
已经会调用DLL的朋友，对功能性SDK的操作可以说是轻松驾驭的啦，看一下壳具体的API手册就OK。  
二、加密型SDK  
通常加密型SDK于壳化挂钩，加密壳在软件中发觉特定的SDK标记后，将采用针对性方法对这一段代码进行针对性处理提高特定代码段的安全性。这种标记自然就是成对定义的汇编代码！  
在易里边我们可以使用置入代码（）命令轻松调用汇编代码。具体到加密壳使用这块，我们按照如下方法做。  
打开加密壳自带的SDK，找一门自己可以读懂的语言SDK头文件看一下。例如下面这一段LCC的头文件。  
以下内容为程序代码:  
1 #elif defined(\_\_LCC\_\_)   
2 /* Provided by Rubem Pechansky, 26Feb2003 */   
3 #define SECUREBEGIN _asm(".byte 0xEB,0x03,0xD6,0xD6,0x00");   
4 #define SECUREEND _asm(".byte 0xEB,0x03,0xD6,0xD6,0xFF");   
5 #define SECUREBEGIN\_A \_asm(".byte 0xEB,0x03,0xD6,0xD6,0x01");   
6 #define SECUREEND\_A \_asm(".byte 0xEB,0x03,0xD6,0xD6,0xFF");   
7 #define SECUREBEGIN\_B \_asm(".byte 0xEB,0x03,0xD6,0xD6,0x02");   
8 #define SECUREEND\_B \_asm(".byte 0xEB,0x03,0xD6,0xD6,0xFF");   
9 #define SECUREBEGIN\_C \_asm(".byte 0xEB,0x03,0xD6,0xD6,0x03");   
10 #define SECUREEND\_C \_asm(".byte 0xEB,0x03,0xD6,0xD6,0xFF");   
11 #define SECUREBEGIN\_D \_asm(".byte 0xEB,0x03,0xD6,0xD6,0x04");   
12 #define SECUREEND\_D \_asm(".byte 0xEB,0x03,0xD6,0xD6,0xFF");   
13 #define SECUREBEGIN\_E \_asm(".byte 0xEB,0x03,0xD6,0xD6,0x05");   
14 #define SECUREEND\_E \_asm(".byte 0xEB,0x03,0xD6,0xD6,0xFF");   
15 #define SECUREBEGIN\_F \_asm(".byte 0xEB,0x03,0xD6,0xD6,0x06");   
16 #define SECUREEND\_F \_asm(".byte 0xEB,0x03,0xD6,0xD6,0xFF");   
17 #define SECUREBEGIN\_G \_asm(".byte 0xEB,0x03,0xD6,0xD6,0x07");   
18 #define SECUREEND\_G \_asm(".byte 0xEB,0x03,0xD6,0xD6,0xFF");   
19 #define SECUREBEGIN\_H \_asm(".byte 0xEB,0x03,0xD6,0xD6,0x08");   
20 #define SECUREEND\_H \_asm(".byte 0xEB,0x03,0xD6,0xD6,0xFF");   
21 #define SECUREBEGIN\_I \_asm(".byte 0xEB,0x03,0xD6,0xD6,0x09");   
22 #define SECUREEND\_I \_asm(".byte 0xEB,0x03,0xD6,0xD6,0xFF");   
23 #define SECUREBEGIN\_J \_asm(".byte 0xEB,0x03,0xD6,0xD6,0x0A");   
24 #define SECUREEND\_J \_asm(".byte 0xEB,0x03,0xD6,0xD6,0xFF");   
25 #define SECUREBEGIN\_K \_asm(".byte 0xEB,0x03,0xD6,0xD6,0x0B");   
26 #define SECUREEND\_K \_asm(".byte 0xEB,0x03,0xD6,0xD6,0xFF");   
27 #define NANOBEGIN _asm(".byte 0xEB,0x03,0xD6,0xD7,0x01");   
28 #define NANOEND _asm(".byte 0xEB,0x03,0xD6,0xD7,0x00");  
用最后两句做解释，NANOBEGIN和NANOEND是C语言的CC代码段标记，被这两个标记包住的代码段，加密壳才会对其进行CC保护处理。NANOBEGIN 用汇编代码表示为 0xEB,0x03,0xD6,0xD7,0x01 ，他这句是C的16进制表示形式，在E里汇编语句是采用10进制表示的。也就是我们要翻译下这句代码。  
0xEB = 235   
0x03 = 3   
0xD6 = 214   
0xD7 = 215   
0x01 = 1   
那么NANOBEGIN在E语言里表现形式就是 置入代码({235, 3, 214, 215, 1}) 。